#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
set -e
# Treat unset variables as an error.
set -u
# Cause a pipeline to return the exit status of the last command in the pipe that returned a non-zero return value.
set -o pipefail

echo "üöÄ Go Project Scaffolder with TUI (Bubble Tea), Cobra & Markdown (Glamour) üöÄ"
echo "-----------------------------------------------------------------------------"

# 1. Check for Go installation
if ! command -v go &>/dev/null; then
  echo "‚ùå Go is not installed. Please install Go and try again."
  echo "   Visit https://golang.org/doc/install"
  exit 1
fi
echo "‚úÖ Go installation found: $(go version)"
echo ""

# 2. Get Project Name
read -r -p "Enter your project name (e.g., my-cool-app): " PROJECT_NAME
if [ -z "$PROJECT_NAME" ]; then
  echo "‚ùå Project name cannot be empty."
  exit 1
fi

# Sanitize project name (lowercase, dashes for spaces, remove special chars)
PROJECT_NAME=$(echo "$PROJECT_NAME" | tr '[:upper:]' '[:lower:]' | tr -s ' ' '-' | sed 's/[^a-z0-9-]//g')

if [ -z "$PROJECT_NAME" ]; then
  echo "‚ùå Sanitized project name is empty. Please use a valid name."
  exit 1
fi

echo "‚û°Ô∏è Project will be created as: $PROJECT_NAME"
echo ""

# 3. Create Project Directory
if [ -d "$PROJECT_NAME" ]; then
  read -r -p "‚ö†Ô∏è Directory '$PROJECT_NAME' already exists. Overwrite? (y/N): " OVERWRITE
  if [[ ! "$OVERWRITE" =~ ^[Yy]$ ]]; then
    echo "Aborted by user."
    exit 0
  fi
  echo "üîÑ Removing existing directory '$PROJECT_NAME'..."
  rm -rf "$PROJECT_NAME"
fi

echo "üìÅ Creating project directories..."
mkdir -p "$PROJECT_NAME/cmd"
mkdir -p "$PROJECT_NAME/internal/tui"
# mkdir -p "$PROJECT_NAME/pkg" # Optional: for public library code

cd "$PROJECT_NAME" || {
  echo "‚ùå Failed to change directory to $PROJECT_NAME"
  exit 1
}
echo "‚úÖ Created project directory structure in: $(pwd)"
echo ""

# 4. Initialize Go Module
# For simplicity, module path is the project name.
# For public projects, you might use: github.com/yourusername/$PROJECT_NAME
MODULE_PATH="$PROJECT_NAME"
echo "üõ† Initializing Go module as '$MODULE_PATH'..."
go mod init "$MODULE_PATH"
echo "‚úÖ Go module initialized."
echo ""

# 5. Install Go Packages
echo "üì¶ Installing Go packages (Cobra, Bubble Tea, Lip Gloss, Glamour)..."
# Using -u to get latest versions.
go get -u github.com/spf13/cobra@latest
go get -u github.com/charmbracelet/bubbletea@latest
go get -u github.com/charmbracelet/lipgloss@latest # Often used with Bubble Tea for styling
go get -u github.com/charmbracelet/glamour@latest  # For Markdown rendering
echo "‚úÖ Packages installed."
echo ""

# 6. Create .gitignore
echo "üìÑ Creating .gitignore file..."
cat <<'EOF' >.gitignore
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool
*.out

# Dependency directories
# vendor/

# Go workspace file
go.work
go.work.sum

# Environment variables
.env*
*.env
!.env.example

# Build output
/build/
# Project binary (will be same as project name)
EOF
# Append project name to .gitignore
echo "/$PROJECT_NAME" >>.gitignore
echo "‚úÖ .gitignore created."
echo ""

# 7. Create main.go
echo "üìù Creating main.go..."
cat <<EOF >main.go
package main

import (
	// Make sure this import path matches your module path defined in go.mod
	// If MODULE_PATH was "$PROJECT_NAME", this should be correct.
	"$MODULE_PATH/cmd"
)

func main() {
	// This Execute function will be generated by Cobra and will
	// call the root command of your CLI application.
	cmd.Execute()
}
EOF
echo "‚úÖ main.go created."
echo ""

# 8. Create cmd/root.go
echo "üìù Creating cmd/root.go..."
cat <<EOF >cmd/root.go
package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "$PROJECT_NAME",
	Short: "A brief description of your $PROJECT_NAME application",
	Long: \`A longer description for $PROJECT_NAME that spans multiple lines
and likely contains examples and usage of using your application.
For example:

Cobra is a CLI library for Go that empowers applications.
This application is a sample generated by the Go project scaffolder.\`,
	// Uncomment the following line if your bare application
	// has an action associated with it:
	// Run: func(cmd *cobra.Command, args []string) {
	//    fmt.Println("$PROJECT_NAME called")
	// },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "‚ùå Whoops. There was an error while executing your CLI: %s\n", err)
		os.Exit(1)
	}
}

func init() {
	// Here you will define your flags and configuration settings.
	// Cobra supports persistent flags, which, if defined here,
	// will be global for your application.
	// Example:
	// rootCmd.PersistentFlags().String("config", "", "config file (default is \$HOME/.$PROJECT_NAME.yaml)")

	// Cobra also supports local flags, which will only run
	// when this action is called directly.
	// Example:
	// rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}
EOF
echo "‚úÖ cmd/root.go created."
echo ""

# 9. Create internal/tui/model.go (Bubble Tea Model)
echo "üìù Creating internal/tui/model.go..."
cat <<EOF >internal/tui/model.go
package tui

import (
	"fmt"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// Model defines the state of our TUI application.
type Model struct {
	choices  []string         // items to choose from
	cursor   int              // which item our cursor is pointing at
	selected map[int]struct{} // which items are selected
	header   string           // a header message for the TUI
	styles   Styles           // for styling
}

// Styles holds lipgloss styles for the TUI.
type Styles struct {
	Header    lipgloss.Style
	Choice    lipgloss.Style
	Cursor    lipgloss.Style
	Selected  lipgloss.Style
	Help      lipgloss.Style
}

// DefaultStyles creates a new set of default styles.
func DefaultStyles() Styles {
	// Example styles using Lip Gloss.
	// You can customize these colors and styles extensively.
	// See https://github.com/charmbracelet/lipgloss for more options.
	return Styles{
		Header:   lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("63")).MarginBottom(1), // Purple
		Choice:   lipgloss.NewStyle().PaddingLeft(2),
		Cursor:   lipgloss.NewStyle().Foreground(lipgloss.Color("205")).Bold(true), // Pink
		Selected: lipgloss.NewStyle().Foreground(lipgloss.Color("42")).Bold(true), // Green
		Help:     lipgloss.NewStyle().Foreground(lipgloss.Color("240")).PaddingTop(1), // Gray
	}
}

// NewModel initializes a new TUI model.
func NewModel(header string, choices []string) Model {
	return Model{
		choices:  choices,
		selected: make(map[int]struct{}), // Initialize the map
		header:   header,
		styles:   DefaultStyles(),
	}
}

// Init is the first function that will be called. It returns an optional
// initial command.
func (m Model) Init() tea.Cmd {
	// Just return nil, no initial command needed for this example.
	return nil
}

// Update is called when a message is received. Use it to inspect messages
// and update the model state.
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	// Is it a key press?
	case tea.KeyMsg:
		// Cool, what was the actual key pressed?
		switch msg.String() {
		// These keys should exit the program.
		case "ctrl+c", "q":
			return m, tea.Quit

		// The "up" and "k" keys move the cursor up.
		case "up", "k":
			if m.cursor > 0 {
				m.cursor--
			}

		// The "down" and "j" keys move the cursor down.
		case "down", "j":
			if m.cursor < len(m.choices)-1 {
				m.cursor++
			}

		// The "enter" key and the spacebar (a literal space) toggle
		// the selected state for the item under the cursor.
		case "enter", " ":
			_, ok := m.selected[m.cursor]
			if ok {
				delete(m.selected, m.cursor) // Unselect
			} else {
				m.selected[m.cursor] = struct{}{} // Select
			}
		}
	}

	// Return the updated model to Bubble Tea
	return m, nil
}

// View renders the TUI.
func (m Model) View() string {
	// The header
	s := m.styles.Header.Render(m.header) + "\n"

	// Iterate over our choices
	for i, choice := range m.choices {
		// Is the cursor pointing at this choice?
		cursor := " " // no cursor
		if m.cursor == i {
			cursor = m.styles.Cursor.Render(">") // cursor!
		}

		// Is this choice selected?
		checked := " " // not selected
		if _, ok := m.selected[i]; ok {
			// Use a different style for selected items
			checked = m.styles.Selected.Render("‚úî") // selected!
		}

		// Render the row
		choiceText := m.styles.Choice.Render(choice)
		if m.cursor == i { // Apply cursor styling to the choice text as well for better visibility
			choiceText = m.styles.Cursor.Render(choice)
		}
		if _, ok := m.selected[i]; ok && m.cursor !=i { // Ensure selected items also stand out if not under cursor
             choiceText = m.styles.Selected.Render(choice)
        }


		s += fmt.Sprintf("%s [%s] %s\n", cursor, checked, choiceText)
	}

	// The footer
	s += m.styles.Help.Render("Use arrow keys (or j/k) to navigate. Space/Enter to select. Q or Ctrl+C to quit.")

	// Send the UI for rendering
	return s
}
EOF
echo "‚úÖ internal/tui/model.go created."
echo ""

# 10. Create cmd/tuiCmd.go
echo "üìù Creating cmd/tuiCmd.go..."
cat <<EOF >cmd/tuiCmd.go
package cmd

import (
	"fmt"
	"os"

	// Adjust this import path to match your module structure
	// If your module is "cognitive-app", it would be "cognitive-app/internal/tui"
	"$MODULE_PATH/internal/tui" 
	tea "github.com/charmbracelet/bubbletea"
	"github.com/spf13/cobra"
)

// tuiCmd represents the tui command
var tuiCmd = &cobra.Command{
	Use:   "tui",
	Short: "Launch an interactive TUI example",
	Long: \`This command starts a sample interactive Terminal User Interface (TUI)
built with Bubble Tea. You can navigate with arrow keys (or j/k) and make selections
using Space or Enter.\`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("üöÄ Launching TUI example...")

		initialChoices := []string{
			"Learn Go Concurrency",
			"Build a Web Server with Gin",
			"Explore Charm Bracelet Tools (Lip Gloss, Glow)",
			"Contribute to an Open Source Project",
			"Drink More Water üíß",
			"Read a New Technical Book",
		}

		// Initialize your TUI model
		// The module path "$MODULE_PATH/internal/tui" should be correct
		// if MODULE_PATH was set from PROJECT_NAME.
		model := tui.NewModel("‚ú® What are your awesome goals today? ‚ú®", initialChoices)

		// Start the Bubble Tea program.
		// Using tea.WithAltScreen() is good practice for TUIs that take over the screen.
		// tea.WithMouseCellMotion() can be added if you want mouse support.
		p := tea.NewProgram(model, tea.WithAltScreen())
		
		// Run the program.
		// p.Run() returns the final model state and an error.
		finalModel, err := p.Run()
		if err != nil {
			fmt.Printf("‚ùå Oh no, there was an error running the TUI: %v\n", err)
			os.Exit(1)
		}

		// You can optionally inspect the finalModel here.
		// The 'm' variable was causing a "declared and not used" error if not used.
		// Using '_' (blank identifier) if you don't need to use the returned model's state here.
		// THIS IS THE CORRECTED LINE to avoid "m declared and not used":
		if _, ok := finalModel.(tui.Model); ok {
			// This block executes if the final model is of type tui.Model.
			// You could, for example, print the selected items or perform other actions
			// based on the final state of the TUI.
			// For this example, we just print a friendly message.
			fmt.Println("\nüëã TUI session ended. Hope you had fun and made some choices!")
		} else {
			// This else block is unlikely to be hit if p.Run() succeeded without error
			// and the program was initialized with tui.Model, but it's good for completeness.
			fmt.Println("\nüëã TUI session ended.")
		}
	},
}

func init() {
	rootCmd.AddCommand(tuiCmd)

	// Here you can define flags specific to this command. For example:
	// tuiCmd.Flags().StringP("item", "i", "", "Add a new item to the list (example flag)")
}
EOF
echo "‚úÖ cmd/tuiCmd.go created."
echo ""

# 11. Create cmd/renderCmd.go (Glamour for Markdown)
echo "üìù Creating cmd/renderCmd.go..."
cat <<EOF >cmd/renderCmd.go
package cmd

import (
	"fmt"
	"os"
	"strings"

	"github.com/charmbracelet/glamour"
	"github.com/spf13/cobra"
)

// renderCmd represents the render command
var renderCmd = &cobra.Command{
	Use:   "render-md",
	Short: "Render a sample Markdown string to the terminal",
	Long: \`This command demonstrates rendering a Markdown string directly to the
terminal using the Glamour library. Glamour is the Markdown rendering
engine used by Glow.
This example shows some basic Markdown features.\`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("üé® Rendering sample Markdown with Glamour...")

		// Sample Markdown content.
		// Using backticks for multi-line strings in Go.
		// Note the escaping of internal backticks for the Go code block within the Markdown.
		markdownContent := \`
# Hello from $PROJECT_NAME!

This is a **Markdown** document rendered by **Glamour**.

It's pretty _neat_, right? You can use various styles.

## Features Demonstrated:
- Lists:
  - Unordered list item 1
  - Unordered list item 2
    - Nested item
- Code blocks (Go):
  \` + \`\` + \`\` + \`go
  package main

  import "fmt"

  func main() {
    fmt.Println("Hello, Glamour in Go!")
  }
  \` + \`\` + \`\` + \`
- Blockquotes:
  > "The only way to do great work is to love what you do." - Steve Jobs
- Horizontal Rules:
  ---
- Links:
  [Visit Charm Bracelet on GitHub](https://github.com/charmbracelet)

Enjoy using Glamour for your Markdown rendering needs!
\`

		// Create a Glamour renderer.
		// You can choose a specific style like glamour.DarkStyle, glamour.LightStyle,
		// or use glamour.WithAutoStyle() to attempt to detect the terminal's theme.
		// glamour.WithWordWrap(width) sets the word wrap width.
		// For more options, see the Glamour documentation.
		renderer, err := glamour.NewTermRenderer(
			glamour.WithAutoStyle(),    // Automatically detect terminal theme (dark/light)
			glamour.WithWordWrap(100),  // Adjust wrap width as needed for your terminal
			// glamour.WithStandardStyle("dracula"), // Example of using a specific built-in style
		)
		if err != nil {
			fmt.Printf("‚ùå Error creating Glamour renderer: %v\n", err)
			os.Exit(1)
		}

		// Render the Markdown
		out, err := renderer.Render(markdownContent)
		if err != nil {
			fmt.Printf("‚ùå Error rendering Markdown: %v\n", err)
			os.Exit(1)
		}

		// Print the rendered output.
		// strings.TrimSpace can be useful if Glamour adds extra newlines.
		fmt.Println(strings.TrimSpace(out))
	},
}

func init() {
	rootCmd.AddCommand(renderCmd)

	// You could add a flag to load markdown from a file:
	// renderCmd.Flags().StringP("file", "f", "", "Path to a markdown file to render")
	// Then in Run, you would read the file content if the flag is set.
}
EOF
echo "‚úÖ cmd/renderCmd.go created."
echo ""

# 12. Tidy up Go module
echo "üßπ Tidying Go module (go mod tidy)..."
go mod tidy
echo "‚úÖ Go module tidied."
echo ""

# 13. Final Instructions
echo "-----------------------------------------------------------------------------"
echo "üéâ Project '$PROJECT_NAME' created successfully! üéâ"
echo ""
echo "To get started:"
echo "1. Your project is located at: $(pwd)"
echo "   (You are already in this directory if the script ran successfully)"
echo ""
echo "2. Try running the help command for your application:"
echo "   go run main.go --help"
echo ""
echo "3. Launch the sample TUI application:"
echo "   go run main.go tui"
echo ""
echo "4. Render sample Markdown to your terminal:"
echo "   go run main.go render-md"
echo ""
echo "To build a binary:"
echo "   go build -o $PROJECT_NAME main.go"
echo "   (This will create an executable named '$PROJECT_NAME' in the current directory)"
echo ""
echo "Then you can run the compiled binary directly:"
echo "   ./$PROJECT_NAME --help"
echo "   ./$PROJECT_NAME tui"
echo "   ./$PROJECT_NAME render-md"
echo ""
echo "üí° Tip: For public repositories, you might want to re-initialize your Go module"
echo "   with a path like 'github.com/yourusername/$PROJECT_NAME' before your first commit."
echo "   You would then need to update the import paths in your .go files accordingly."
echo "   For example, in main.go, change \"$MODULE_PATH/cmd\" to \"github.com/yourusername/$PROJECT_NAME/cmd\"."
echo ""
echo "Happy coding with Go, Cobra, Bubble Tea, and Glamour! ‚ú®"
echo "-----------------------------------------------------------------------------"

# The script automatically cds into the project directory.
# No need to tell the user to `cd $PROJECT_NAME` as they are already there.
